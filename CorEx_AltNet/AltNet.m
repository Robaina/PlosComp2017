function Sol=AltNetCORDA(GEM,HC,MC,NC,OT,Z_MC,Z_NC,Z_OT,A,Vmax,epsilon,Nmodels,time_limit,PerFraction,IterLimit)

%*****************The AltNet procedure(CORDA adaptation)*******************
%**************************************************************************

%This function implements the AltNet procedure to generate alternative
%optimal networks to the CORDA optimum.
%
%Required arguments are:
  %GEM: COBRA-like structure with the GEM
  
  %HC,MC,NC,OT: arrays with the indexes in the GEM of the reactions in the
  %HC, MC, NC and OT sets.
  
  %Z_HC, Z_MC, Z_NC, Z_OT: the number of added reaction in each one of the
  %four categories. These values should equal the ones obtained by CORDA at
  %the optimum.
  
  %A: an array generated by the CorExCORDA function, it contains the
  %indexes in the GEM of the reactions in the optimal context-specific
  %model.
  
%Optional values are:
  %Vmax: an upper bound for the maximum flux value of any reaction (in
  %reversibles the bound would be -Vmax <= v <= Vmax), default 1e3
  
  %epsilon: the numerical threshold to consider a reaction active (default
  %1e-3)
  
  %Nmodels: number of generated alternative optimal models
  
  %time-limit: a time limit (in seconds) for an early termination of the
  %MILP (default 60s)
  
  %PerFraction: a number between 0 and 1, it is used as an optional
  %perturbation to the initial binary state of the optimization, as to
  %avoid the program to get stuck in a single alternative optimal model. It
  %indicates the  fraction of the added reactions which will have its
  %initial state randomly perturbed.
  
  %IterLimit: an upper bound on the number of iterations in the main loop.
  %The loop continues until Nmodels is satisfied or the number of
  %iterations reaches IterLimit
  
%**************************************************************************
%           SemidÃ¡n (robaina@mpimp-golm.mpg.de), May, 2016
%**************************************************************************

if nargin<10 || isempty(Vmax),
    Vmax=1e3;
end
if nargin<11 || isempty(epsilon),
    epsilon=0.001;
end
if nargin<12 || isempty(Nmodels),
    Nmodels=10;
end
if nargin<13 || isempty(time_limit),
    time_limit=60;
end
if nargin<14 || isempty(PerFraction),
    PerFraction=0.1;
end
if nargin<15 || isempty(IterLimit),
    IterLimit=Nmodels;
end

RevRxns=find(GEM.rev==1);
IrrRxns=find(GEM.rev==0);
NRev=length(RevRxns);
NIrr=length(IrrRxns);
P=setdiff(1:length(GEM.rxns),HC);
S=GEM.S;

%Classify reactions
Irr_HC=intersect(HC,IrrRxns);
Irr_MC=intersect(MC,IrrRxns);
Irr_NC=intersect(NC,IrrRxns);
Irr_OT=intersect(OT,IrrRxns);
Irr_P=intersect(P,IrrRxns);
Rev_HC=intersect(HC,RevRxns);
Rev_MC=intersect(MC,RevRxns);
Rev_NC=intersect(NC,RevRxns);
Rev_OT=intersect(OT,RevRxns);
Rev_P=intersect(P,RevRxns);
NIrr_HC=length(Irr_HC);
NIrr_MC=length(Irr_MC);
NIrr_NC=length(Irr_NC);
NIrr_OT=length(Irr_OT);
NIrr_P=length(Irr_P);
NRev_HC=length(Rev_HC);
NRev_MC=length(Rev_MC);
NRev_NC=length(Rev_NC);
NRev_OT=length(Rev_OT);
NRev_P=length(Rev_P);

%Stoichiometric Matrix reorganization
Sam=[S(:,Irr_HC),S(:,[Irr_MC;Irr_NC;Irr_OT]),S(:,Rev_HC),S(:,[Rev_MC;Rev_NC;Rev_OT]),-S(:,Rev_HC),-S(:,[Rev_MC;Rev_NC;Rev_OT])];  
Rxns=size(Sam,2);
Mets=size(Sam,1);

%Construction of Amat matrix (virr_C,virr_P,vfor_C,vfor_P,vrev_C,vrev_P,xirr(MC,NC,OT),xRev(MC,NC,OT),y,delta+,delta-)
A1=[Sam,zeros(Mets,NIrr_P+NRev_P+NRev+2*(NIrr_P+NRev_P))]; %SV=0
A2=[eye(NIrr_HC),zeros(NIrr_HC,NIrr_P+2*NRev+NIrr_P+NRev_P+NRev+2*(NIrr_P+NRev_P))]; %virr_HC>=epsilon 
A3=[zeros(NRev_HC,NIrr),eye(NRev_HC),zeros(NRev_HC,NRev_P),eye(NRev_HC),zeros(NRev_HC,NRev_P+NIrr_P+NRev_P+NRev+2*(NIrr_P+NRev_P))]; %vfor_C+vrev_HC>=epsilon

A4a=[zeros(NIrr_P,NIrr_HC),eye(NIrr_P),zeros(NIrr_P,2*NRev),-Vmax*eye(NIrr_P),zeros(NIrr_P,NRev_P+NRev+2*(NIrr_P+NRev_P))]; %virr_p-xirr*Vmax<=0
A4b=[zeros(NIrr_P,NIrr_HC),eye(NIrr_P),zeros(NIrr_P,2*NRev),-epsilon*eye(NIrr_P),zeros(NIrr_P,NRev_P+NRev+2*(NIrr_P+NRev_P))]; %virr_p-xirr*epsilon>=0

A5a=[zeros(NRev_P,NIrr+NRev_HC),eye(NRev_P),zeros(NRev_P,NRev_HC),eye(NRev_P),zeros(NRev_P,NIrr_P),-Vmax*eye(NRev_P),zeros(NRev_P,NRev+2*(NIrr_P+NRev_P))]; %(vfor_p+vback_p)-xRev*Vmax<=0
A5b=[zeros(NRev_P,NIrr+NRev_HC),eye(NRev_P),zeros(NRev_P,NRev_HC),eye(NRev_P),zeros(NRev_P,NIrr_P),-epsilon*eye(NRev_P),zeros(NRev_P,NRev+2*(NIrr_P+NRev_P))]; %(vfor_p+vback_p)-xRev*epsilon>=0

A7=[zeros(NRev,NIrr),eye(NRev),zeros(NRev,NRev+NIrr_P+NRev_P),Vmax*eye(NRev),zeros(NRev,+2*(NIrr_P+NRev_P))]; %vfor+y*Vmax<=Vmax
A8=[zeros(NRev,NIrr+NRev),eye(NRev),zeros(NRev,NIrr_P+NRev_P),-Vmax*eye(NRev),zeros(NRev,+2*(NIrr_P+NRev_P))]; %vrev-y*Vmax<=0

%These constraints are modified to account for CORDA: the inclusion of a
%given number of MC and NC and OT reactions.
A9a=[zeros(1,Rxns),ones(1,NIrr_MC),zeros(1,NIrr_NC+NIrr_OT),ones(1,NRev_MC),zeros(1,NRev_NC+NRev_OT+NRev+2*(NIrr_P+NRev_P))]; %||x_mc||_1<Z_MC+epsilon
A9b=[zeros(1,Rxns),ones(1,NIrr_MC),zeros(1,NIrr_NC+NIrr_OT),ones(1,NRev_MC),zeros(1,NRev_NC+NRev_OT+NRev+2*(NIrr_P+NRev_P))]; %||x_mc||_1>Z_MC-epsilon

A9c=[zeros(1,Rxns+NIrr_MC),ones(1,NIrr_NC),zeros(1,NIrr_OT+NRev_MC),ones(1,NRev_NC),zeros(1,NRev_OT+NRev+2*(NIrr_P+NRev_P))]; %||x_nc||_1<Z_NC+epsilon
A9d=[zeros(1,Rxns+NIrr_MC),ones(1,NIrr_NC),zeros(1,NIrr_OT+NRev_MC),ones(1,NRev_NC),zeros(1,NRev_OT+NRev+2*(NIrr_P+NRev_P))]; %||x_nc||_1>Z_NC-epsilon

A9e=[zeros(1,Rxns+NIrr_MC+NIrr_NC),ones(1,NIrr_OT),zeros(1,NRev_MC+NRev_NC),ones(1,NRev_OT),zeros(1,NRev+2*(NIrr_P+NRev_P))]; %||x_ot||_1<Z_OT+epsilon
A9f=[zeros(1,Rxns+NIrr_MC+NIrr_NC),ones(1,NIrr_OT),zeros(1,NRev_MC+NRev_NC),ones(1,NRev_OT),zeros(1,NRev+2*(NIrr_P+NRev_P))]; %||x_ot||_1>Z_OT-epsilon

A10=[zeros(NIrr_P+NRev_P,Rxns),eye(NIrr_P+NRev_P),zeros(NIrr_P+NRev_P,NRev),eye(NIrr_P+NRev_P),-eye(NIrr_P+NRev_P)]; %delta+ - delta- +x =Xopt
A11=[zeros(NIrr_P+NRev_P,Rxns+NIrr_P+NRev_P+NRev),eye(NIrr_P+NRev_P),eye(NIrr_P+NRev_P)]; %delta+ + delta- <= 1
Amat=[A1;A2;A3;A4a;A4b;A5a;A5b;A7;A8;A9a;A9b;A9c;A9d;A9e;A9f;A10;A11];

%Construction of c, lb, ub, sense and b vectors
c=[zeros(Rxns+NIrr_P+NRev_P+NRev,1);ones(2*(NIrr_P+NRev_P),1)];
vsense=[repmat('=',Mets,1);repmat('>',NIrr_HC+NRev_HC,1);repmat('<',NIrr_P,1);repmat('>',NIrr_P,1);repmat('<',NRev_P,1);repmat('>',NRev_P,1);repmat('<',2*NRev,1);'<';'>';'<';'>';'<';'>';repmat('=',NIrr_P+NRev_P,1);repmat('<',NIrr_P+NRev_P,1)];
vtype=[repmat('C',Rxns,1);repmat('B',NIrr_P+NRev_P+NRev,1);repmat('B',2*(NIrr_P+NRev_P),1)];
lb=zeros(size(Amat,2),1);
ub=[Vmax*ones(Rxns,1);ones(NIrr_P+NRev_P+NRev+2*(NIrr_P+NRev_P),1)];

%Prepare gurobi structure
model.A=sparse(Amat);
model.modelsense='max';
model.obj=c;
model.sense=vsense;
model.lb=lb;
model.ub=ub;
model.vtype=vtype;
params.OutputFlag=0;
params.FeasibilityTol=1e-9;
params.IntFeasTol=1e-9;
params.TimeLimit=time_limit;
% params.presolve=2;

%Reconstruct vector x of binary variables
Abinary=zeros(length(GEM.rxns),1);
Abinary(A)=1;
Xopt=Abinary([Irr_MC;Irr_NC;Irr_OT;Rev_MC;Rev_NC;Rev_OT]);

%Start Iteration
Xopt2=Xopt;
Vmatrix=zeros(length(GEM.rxns),Nmodels);
Modmatrix=zeros(length(GEM.rxns),Nmodels+1);
QualityCheck=zeros(Nmodels,2);
MaxDifferences=zeros(Nmodels+1,1);
Xoptmatrix=zeros(length(Xopt2),Nmodels+1);
wbar=waitbar(0,'Getting Alternative Networks...');
netcounter=1;itercounter=1;
Modmatrix(:,1)=Abinary;
Xoptmatrix(:,1)=Xopt2;
tic
while (netcounter<=Nmodels) && itercounter<=IterLimit,
    waitbar(netcounter/Nmodels)
    itercounter=itercounter+1;
    %Solve MILP
    model.rhs=[zeros(Mets,1);epsilon*ones(NIrr_HC+NRev_HC,1);zeros(2*NIrr_P+2*NRev_P,1);Vmax*ones(NRev,1);zeros(NRev,1);Z_MC+0.5;Z_MC-0.5;Z_NC+0.5;Z_NC-0.5;Z_OT+0.5;Z_OT-0.5;Xopt2;ones(NIrr_P+NRev_P,1)];
    model.start=[NaN*ones(Rxns,1);Xopt2;NaN*ones(NRev+2*(NIrr_P+NRev_P),1)];
    gur=gurobi(model,params);
    Xoptmatrix(:,netcounter+1)=Xopt2;
    try
      Xopt2=gur.x(Rxns+1:Rxns+NIrr_P+NRev_P);
      Vmatrix(Irr_HC,netcounter)=gur.x(1:NIrr_HC);
      Vmatrix(Irr_MC,netcounter)=gur.x((NIrr_HC+1):(NIrr_HC+NIrr_MC));
      Vmatrix(Irr_NC,netcounter)=gur.x((NIrr_HC+NIrr_MC+1):(NIrr_HC+NIrr_MC+NIrr_NC));
      Vmatrix(Irr_OT,netcounter)=gur.x((NIrr_HC+NIrr_MC+NIrr_NC+1):(NIrr_HC+NIrr_MC+NIrr_NC+NIrr_OT));
      Vmatrix(Rev_HC,netcounter)=gur.x(NIrr+1:NIrr+NRev_HC)-gur.x(NIrr+NRev+1:NIrr+NRev+NRev_HC);
      Vmatrix(Rev_MC,netcounter)=gur.x(NIrr+NRev_HC+1:NIrr+NRev_HC+NRev_MC)-gur.x(NIrr+NRev+NRev_HC+1:NIrr+NRev+NRev_HC+NRev_MC);
      Vmatrix(Rev_NC,netcounter)=gur.x(NIrr+NRev_HC+NRev_MC+1:NIrr+NRev_HC+NRev_MC+NRev_NC)-gur.x(NIrr+NRev+NRev_HC+NRev_MC+1:NIrr+NRev+NRev_HC+NRev_MC+NRev_NC);
      Vmatrix(Rev_OT,netcounter)=gur.x(NIrr+NRev_HC+NRev_MC+NRev_NC+1:NIrr+NRev_HC+NRev_MC+NRev_NC+NRev_OT)-gur.x(NIrr+NRev+NRev_HC+NRev_MC+NRev_NC+1:NIrr+NRev+NRev_HC+NRev_MC+NRev_NC+NRev_OT);
      Vmatrix(abs(Vmatrix)<(epsilon-0.01*epsilon))=0;
      Modmatrix((abs(Vmatrix(:,netcounter))>0),netcounter+1)=1;
    catch
        Modmatrix(:,netcounter+1)=Modmatrix(:,netcounter);
    end
    
    %Include random perturbation if Xopt is fixed
     if sum(abs(Modmatrix(:,netcounter+1)-Modmatrix(:,netcounter)))==0,
        Xrand=zeros(length(Xopt2),1);Xrand(ceil(length(Xopt2)*rand(round(length(Xopt2)*PerFraction),1)))=1;
        Xopt2=abs(Xopt2-Xrand);
    else
        MaxDifferences(netcounter+1)=sum(abs(Modmatrix(:,netcounter+1)-Modmatrix(:,netcounter)));
        netcounter=netcounter+1;
    end
end

%Assesst quality of the networks: all networks must include the HC SET
%and be consistent (have non-zero flux only in all selected reactions).
%Also, the preselected number of MC, NC and OT reactions must be correct
%and these reactions must carry non-zero flux.
for i=1:size(Vmatrix,2),
    QualityCheck(i,1)=length(find(abs(Vmatrix(HC,i))>0));
    QualityCheck(i,2)=length(find(abs(Vmatrix(MC,i))>0));
    QualityCheck(i,3)=length(find(abs(Vmatrix(NC,i))>0));
    QualityCheck(i,4)=length(find(abs(Vmatrix(OT,i))>0));
    QualityCheck(i,5)=length(find(abs(Vmatrix(:,i))>0));
end
Modmatrix(:,sum(Modmatrix)==0)=[];
QualityCheck=[{'HC Active Rxns','MC Active Rxns','NC Active Rxns','OT Active Rxns','Total Active Rxns'};num2cell(QualityCheck)];
close(wbar)
Sol.Vmatrix=Vmatrix;
Sol.Modmatrix=unique(Modmatrix','rows')';
Sol.maxDiff=MaxDifferences;
Sol.QualityCheck=QualityCheck;
Sol.Xoptmatrix=Xoptmatrix;
Sol.TotalTime=toc;

%Perform metabolic tests
for i=1:size(Sol.Modmatrix,2),
    V=metabolicTest(GEM,find(Sol.Modmatrix(:,i)==1));
    TestScore(i,1)=V.TestScore;
end
%Extract alternative networks passing the test
Sol.ModmatrixTest=Sol.Modmatrix(:,TestScore==1);
Sol.TestScore=TestScore;

end
